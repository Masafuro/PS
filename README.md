# Python Software Sequencer フレームワーク 仕様書

## 概要

本プロジェクトは、Pythonを用いてPLC（シーケンサー）のような定周期スキャンと非同期処理を両立させるための制御フレームワークです。メインの制御ロジックを担う同期実行（Loop）と、通信や重い処理を担う非同期実行（Keep）を安全に分離し、データの整合性を自動で管理します。

## 実行フェーズの構成

プログラムは役割に応じて `src/` フォルダ直下の4つのディレクトリに分割して配置します。

> **起動コマンド:** `python main/sequencer.py`

1. **0_setup**: システム起動時に一度だけ実行される初期化フェーズ。マスター変数の初期設定などに使用します。
2. **3_keep**: メインループとは独立して非同期に実行される常駐タスク。通信やGUIに適しています。
3. **1_loop**: 指定されたサイクル時間ごとに繰り返し実行される制御の核となるフェーズ。
4. **2_teardown**: プログラム終了時に一度だけ実行される終了処理フェーズ。

## 変数の読み書きルールと整合性

本フレームワークは「所有権の保護」に基づき、インポートする変数によってアクセス権限が自動的に切り替わります。

| 変数名 | 主な使用場所 | 動作の性質 |
| --- | --- | --- |
| **`loop_var`** | `1_loop` | **スナップショット・コミット方式**。サイクル中は値が固定され、終了時に `loop` 領域のみマスターへ書き戻されます。 |
| **`keep_var`** | `3_keep` | **ダイレクト・アクセス（制限付き）**。`keep` 領域は即座に反映されます。`loop` 領域は読み取り専用として保護されます。 |
| **`master_var`** | `0_setup`, `2_teardown`, デバッグ | **フルアクセス**。全領域に対して直接読み書きを行います。システムの状態を強制的に変更または確認する場合に使用します。 |

## スクリプトの記述例

### 0_setup / 2_teardown での利用（マスター直接操作）

起動時や終了時は、全権限を持つ `master_var` を使用してシステムの状態を確実にセット・取得します。

```python
from variables import master_var as v

def execute():
    # Setup: 起動時にカウンタをリセット
    v.loop.counter = 0
    # Teardown: 最終的な値をログ出力
    print(f"Final Count: {v.loop.counter}")

```

### 1_loop 側（同期制御）

演算の一貫性を保つため、自分専用の作業領域（`loop_var`）を使用します。

```python
from variables import loop_var as v

def execute():
    v.loop.counter += 1  # 自分の領域を更新
    if v.keep.status == "ACTIVE":
        pass

```

### 3_keep 側（非同期I/O）

外部情報の即時反映のため、直通窓口（`keep_var`）を使用します。

```python
from variables import keep_var as v

def execute():
    # 自分の領域を更新（即座に反映される）
    v.keep.status = "ACTIVE"
    # loop領域を書き換えようとしても自動でブロックされる
    v.loop.counter = -999 

```

---

## 運用上の注意点

* **所有権の遵守**: `loop` 領域の変数は `1_loop` で、`keep` 領域の変数は `3_keep` で更新するのが基本原則です。
* **master_var の使用**: 強力な権限を持つため、通常の制御ロジック内（`1_loop` など）での多用は避け、初期化、終了処理、モニタリングツールなどの「管理者機能」に限定して使用してください。

