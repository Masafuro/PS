# Python Software Sequencer フレームワーク 仕様書

## 概要

本プロジェクトは、Pythonを用いてPLC（シーケンサー）のような定周期スキャンと非同期処理を両立させるための制御フレームワークです。メインの制御ロジックを担う同期実行（Loop）と、通信や重い処理を担う非同期実行（Keep）を安全に分離し、データの整合性を自動で管理する仕組みを提供します。

## 実行フェーズの構成

プログラムは役割に応じて以下の`src/`フォルダ直下に4つに分割して配置され、システムによって管理されます。

> python main/suquencer.py

を実行することで以下の内容が処理されます。`Ctrl+C`等による終了を行うとkeepを停止しteardwon実行後、停止します。

1. **0_setup**: システム起動時に一度だけ実行される初期化フェーズです。
2. **3_keep**: メインループとは独立して非同期に実行される常駐タスクです。ネットワーク通信やGUI、ログ出力などの重い処理に適しています。
3. **1_loop**: 指定されたサイクル時間（デフォルト100ms）ごとに繰り返し実行される制御フェーズです。
4. **2_teardown**: プログラム終了時に一度だけ実行される終了処理フェーズです。

## 変数定義（variables.yaml）

共有変数の定義は `src/common/variables.yaml` で一括管理されます。コードを修正することなく、このファイルを編集するだけで新しい変数を追加できます。変数は役割に応じて2つの領域に分類されます。

* **loop領域**: メインループ（1_loop）が更新の主導権を持つ変数群です。
* **keep領域**: 常駐タスク（3_keep）が更新の主導権を持つ変数群です。

## 変数の読み書きルールと整合性

本フレームワークは、高速スキャンを実現するために「スナップショット・コミット方式」を採用しています。これにより、実行中にデータが書き換わることによるロジックの破綻を防ぎます。

### 1_loop での利用

`from variables import loop_var` を使用します。

* **loop領域へのアクセス**: 読み書きともに可能です。書き換えた値はサイクルの終了時に確定され、次のサイクルへ引き継がれます。
* **keep領域へのアクセス**: 読み取りを主目的とします。スキャンの最初に取得した「その時点の最新値」がサイクル中固定されます。書き換えることも可能ですが、その変更はマスターには反映されず、次のサイクルではリセットされます。

### 3_keep での利用

`from variables import master_var` を使用します。

* 非同期に動作するため、常にマスターデータに対して直接読み書きを行います。ここで書き込んだ内容は、次のメインループのスキャン開始時にスナップショットとして取り込まれます。

## スクリプトの書き方

各フォルダに配置するスクリプトは、以下の形式で記述します。

```python
from variables import loop_var as v

def execute():
    # 自分の領域を更新（マスターに保存される）
    v.loop.cycle_count += 1
    
    # 相手の領域を参照（スキャン中は値が固定される）
    if v.keep.server_connected:
        # 制御ロジックをここに記述
        pass

```

